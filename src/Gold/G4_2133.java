// 생각을 좀 해봤는데
// 일단 N이 홀수인 경우에는 주어진 타일로 꽉 채울 수 없음. 그래서 이경우는 안되고
// N이 짝수인 경우를 생각해 봐야하는데
// N이 2일때를 한번 따져보면
// 가로2 타일 : 3개 , 가로1 타일: 0개    ---- 1가지
// 가로2 타일 : 1개 , 가로1 타일: 2개   ----- 2가지

// 아직 잘모르겠네 n이 4일때도 따져보면
// 가로2 타일 : 6개 --- 1가지
// 가로2 타일 : 4개 , 가로1 타일: 2개 --- 6가지
// 가로2 타일 : 2개 , 가로1 타일 : 4개 --- 4가지

// 여기서 솔직히 n=6 인거까지 조사하는건 너무 시간낭비니깐  이쯤에서 잠깐 끊어서 생각을 해보자
// 우선 필요한 타일수는 차수가 3인 등차수열이니까
// N = K일때 필요한 타일의 개수는 3*N /2 ( K 는 짝수) 임.

// 그리고 가로2 타일의 개수 가지수가
// N=k 일때 필요한 타일 개수가 a개 라고하면
// a , a-2 , a-4 ... ( > 0 )
// 위와 같단말이지?

// 근데 a일때는 무조건 1이야 일단

// a-2일때는? 가로1 타일 2개가 어디에 배치되느냐가 중요한건데...
// 일단 N=2 일때 가로 1타일 2개 경우가 왼쪽 오른쪽 중 어디에 나오느냐의 경우 ( 2 x 2 )
// 그리고 양 끝에 가로1 타일이 위치할 수 있는데 위 , 아래중 어느 곳에 나올것인가. 이때 양 타일은 같은 방향(위 또는 아래)에 있어야하고. ( 2)
// 그러면 6개. 그니깐정리하면 2*2 + 2 가됨.

// 그러면 좀 유추해볼 수 있는게 만약 N=6이라면? (똑같이 가로 1 타일 2개 배치하는 경우. 즉 a-2에 대해 고려해보자)
// 같은 규칙으로
// 2 *( 6 x 2 )  (N=4 일때 왼 또는 오른, 나머지는 N =2) + 2 (양끝에 등장하는경우)

// a-4일때를 이번에는 따져보자. 이게 따져보는 마지막이될거임.
// 일단 N=4일때로 보는거니까 그러면 가로타일 2개가 어디에 위치되느냐에 집중해야하는데.
// 이건그냥 가로타일이 왼쪽 , 오른쪽 나눴을때 각각 왼쪽 위 , 아래 * 오른쪽 위 ,아래 경우의 수니깐 2 x 2 = 4

// 여기까지 보니깐 생각난게 있음.
// N= 4인 경우는 N= 2의 패턴이 두번 나오는 경우 ( 3 *3 ) + 양 끝에 가로 1 타일 2개 나오는 경우 ( 2) = 11이라는 거임.
// 그러면 N= 6은 N= 4 , N= 2의 패턴이 나오는 경우 ( 11 *3. N=4안에 N= 2의 케이스도 포함이니깐 2는 안곱함)
// + 양 끝에 가로 타일2개 ( 2)
// + N= 4와 N=2 연결부 사이에서 새로운 패턴이나올 때 6가지.
// 하면 41가지.

// 잠깐만 그러면 다시 N=4 일때를 생각해보면
// 3*3 + 2와 2 이음부에서 새로운 패턴이 등장할때 2가지 ( 즉 , 위 또는 아래로 가로2 막대가 2개 위치하는경우) = 11가지.

// 그럼 N= 8일떄는?
// 6일떄와 2일떄 : 41 * 3
// + 6과 2의 이음부에서 뉴패턴 등장.
// 그림을 그려가면서 해보니깐
// 이 떄 이음부에서의 패턴은 (N=4 일때 + N=2알때 + 1 )*2 이었음. (2를 곱하는 이유는 위 또는 애래로 가로막대기 2개가 위치하므로)
// 이제 점화식을 세워보자.

// 시작 식 타일[2] = 3 , 타일[0] = 1 ( 타일[4] 를계산하기 위함)
// 타일[K] = 타일[k-2] * 타일[2] +  2* (타일[k-4] + 타일[K-6] + ... + 1 )  ( K > 3 이며 K는 짝수)-- 이떄 더해지는 1은 tile[0]로 치환.

package Gold;

import java.io.*;
import java.util.Arrays;

public class G4_2133 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int N = Integer.parseInt(br.readLine());
        int[] tile = new int[N+1];

        // index
        int i, j;

        /* 로직 */
        // 로직은 위의 점화식과 같음.
        Arrays.fill(tile, 0);
        tile[0] = 1;
        if(N != 1)
            tile[2] = 3;
        for(i = 4; i <= N ; i+=2){
            tile[i] = tile[i-2]*tile[2];
            for(j = i-4 ; j >= 0 ;j -=2){
                tile[i] += 2*tile[j];
            }
        }
        bw.write(String.valueOf(tile[N]));
        bw.flush();
    }
}
