// 집합을 비트로보고 0 ~ 9 까지 포함하는 케이스를 DP로 만들어서 센다면?..
// 흠 그러면 일단 열은 2^10 = 1024
// 행은 최대 100
// 그러면 102,400 * 8 (혹시나 모르니 long으로 ) = 800KB
// 메모리는 ㅇㅋ.
// 그럼이제 점화식을 세워봐야겠지..
// 시작은 dp[0][0] = 0  dp[0][k] = 1 ( k = 1<<0 , 1<<1 , 1<<2 .. . 1<<9 )
// dp[k][i] = ..
// 근데 생각해보니깐 이게 이전에 마지막으로 나온 수를 고려해야하는데..
// 이전이랑 그 전전거 까지 봐야할듯.

// 근데 그렇게하면 너무 복잡하고 지저분할거같아서
// 3차원 DP배열을 사용하기로 결정..
// 그럼 시간복잡도가.. N번을 도는데 그 내부에서 2^10개에 대해서 각각 10번돌아야하니깐
// N*2^10*10*(10번 내부에서 도는 연산 수) 인데
// 흠.. 그러면 최악에 100* 1024* 10 * ?
// 그럼.. 대충 생각해보면 한 천만 언저리 나올듯?
// 시간복잡도 ㅇㅋ

// 그럼 점화식을 세워보면..
// DP[k][a][b] =  dp[k-1][a ^ (1<< b-1)][b-1] + dp[k-1][a ^ ( 1 << b+1) ][b+1]
// 이런느낌인가? ..
// 아니다 저기다가 dp[k-1][a][b-1] + dp[k-1][a][b+1] 도 더해줘야겠다
// 그러면 .. 될듯?

// 아니근데 해보니깐 안됨;;
// 디버깅을 하려니이게참..

// 해보니깐 원래 세운식이 말이안됐음.
// 0110 이라는 애가 있으면 그전 단계 k=1일때를 해보면 이게 전단계 0100 값을 참조하는게됨.
// 그러면 점화식을 다시세워야할듯.
// 앞선 방식대로라면 10번 내부에서 루프를 또돌아야하는데
// 그게 예를들어서 0111110,,. 이렇게돼있으면 흠.. 0011~ 에대해서도 해봐야하고 0101~~에 대해서도해봐야하고..
// 이건 가지수가 너무많다;;
// 그러면 차라리 다음 레벨에서 bit or 연산을 통해서 해보는것은 어떨까
// 그니깐 현재 수준의 비트집합 | 1<< (마지막수-1 또는 +1) 의 차원을 갱신해주는거지 그니깐
// dp[k+1][a | 1 << (마지막수-1)][마지막수-1] += dp[k][a][마지막수]
// 이런 형태로

package Gold;

import java.io.*;
import java.util.Arrays;

public class G1_1562 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        /*      입력  처리      */
        // index
        int i,j,k;
        int N = Integer.parseInt(br.readLine());
        // N번 반복
        // 2^10번.
        // 0은 000 000 000 1 이런식. N이 1일때 0은 안쳐줌
        // 그다음 차원 10은 .. 마지막 자리수를 나타내는 식으로 해보자
        long[][][] dp = new long[N+1][1<<10][10];

        /*      로직      */
        // 답
        long result = 0;
        // 초기화
        for(i = 0 ; i <N+1 ; i++)
            for(j = 0 ; j < 1<<10 ; j++)
                Arrays.fill(dp[i][j],0);

        for(i = 1; i < 10 ; i++)
            dp[1][1<<i][i] = 1;

        // 최외곽 루프 . N까지 갱신을 해야함..
        for(i = 1 ; i < N ; i++){
            // 그다음.. 2^10 돌면서 갱신을 해야함. 모든 비트가 0인경우는 없으니깐.. 1부터
            for(j = 1; j < 1<<10 ; j++){
                // 위의 점화식대로 해야하는데... 너무복잡하네? ㅋㅋ
                for(k = 0 ; k < 10 ; k++){
                    if(k != 0) {
                        dp[i+1][j | (1<<(k-1))][k-1] += dp[i][j][k];
                        dp[i+1][j | (1<<(k-1))][k-1] %= 1_000_000_000;
                    }
                    if(k != 9){
                        dp[i+1][j | (1<<(k+1))][k+1] += dp[i][j][k];
                        dp[i+1][j | (1<<(k+1))][k+1] %= 1_000_000_000;
                    }
                }
            }
        }
        for(i = 0 ; i < 10 ; i++)
            result+= dp[N][(1<<10)-1][i];
        result %= 1_000_000_000;
        bw.write(String.valueOf(result));
        bw.flush();
    }
}
