/* 2022-06-26 9번째로 푼 문제 */
// 우선 N이 1이면 계단 수는 9이고.
// N이 2보다 큰 경우에는
// 2자릿수의 계단수와 3자릿수의 계단수를 이용.
// 2자릿수의 계단 수는 17 . = ( 8*2 + 1*1 )
// 3자릿수의 계단수는 우선 첫자리가 1인경우 둘째자리에 0이나 2가 올 수 있으므로
// 0이 오는경우 세번째 자릿수에 1만 올 수 있으니까 1가지.   2가 오는경우 0아니 1이 셋째 자리에 올 수 있으니 2가지.
// 첫자리가 2인경우 1또는 3. 각각 2가지 경우가짐.
// 따져보면 1*(1+2) + 6*(2+2) + 1*(2+1) + 1*(2) = 32
// 이 둘을 이용해 예를들어 14자리의 계단수를 구한다고 하면
// 14자리는 2 + (여기서부터 앞에 거 하나 포함)3+  3 + 3+ 3 + 3 + 3 과 같이 쪼개지니까
// 첫 4자리를 앞 2개, 뒤 3개로 묶어서  2자릿수 계단수 * 3자릿수 계단수와 같이 표현 가능하니까
// 이런 방식으로 한번 값을 구해 봄.

// 근데 생각해보니까 이런경우에
// 예를들어 네자릿수면
// 1234라하면
// 123 묶이고 34 묶이고 할텐데
// 3이 0인경우는 포함되지 않음.
// 맨 끝자리수가 0인경우 뒤에 세자릿수가 묶이면 2가지경우가 추가되고 ( 010, 012)
// 뒤에 두자릿수가 묶이면 1가지 경우가 추가 됨. ( 01 )
// 그래서 이런경우를 고려해서 다시 고쳐줌.

// 앞에 방식대로 했는데 틀려서 곰곰히 생각을 해보았는데
// 생각해보니까 예를들어 4자리를 3 , 2 이렇게 묶는다고 하면 단순하게 앞뒤 경우수를 곱해버리면 101  34이런것도 포함하는거니까
// 3의 세번째 자릿수가 뭐냐에따라 다르게 계산해야 한다는걸 깨달음.
// 그래서 다이나믹 프로그래밍 방식을 도입해서
// 100행 10열 배열을 만들고
// 0행은 없는 셈치고 ( 0자릿수 계단수는 없으니까)
// 1행부터 사용.
// 그래서 예시로 4행의 3번쨰열 값을 구한다 하면 ( 4자릿수 계단수의 3으로 끝나는 계단수 갯수)
// 이는 3번째 계단수 2번째열과 4번쨰열을 합친 값.
// 그런식으로 계산해나가면서
// 최종적으로는
// 마지막행의 모든 열값을 싹다 더한후 1,000,000,000으로 나눈 값이 정답이라고 생각했음.
// 이렇게 만들었을 때
// long형으로 만들것이므로 8*100*10 bytes므로 메모리는 넉넉.
// 시간도 1초 제한이므로 1억번의 연산에 한참 못미치므로 넉넉.

package Silver;

import java.util.Scanner;

public class S1_10844 {
    public static void main(String[] args) {
        long sum=0;
        Scanner scanner = new Scanner(System.in);
        int count = scanner.nextInt();
        long[][] result = new long[count+1][10];
        if(count == 1){
            System.out.print("9");
            return ;
        }
        result[1][0] = 0;
        for(int i =1; i < 10 ; i++)
            result[1][i] = 1;

        for(int i = 2; i < count+1 ; i++){
            for(int j = 0 ; j < 10 ; j++){
                if(j == 0){
                    result[i][j] = result[i-1][j+1];
                    if(result[i][j]> 1_000_000_000)
                        result[i][j]%=1_000_000_000;
                }
                else if(j==9){
                    result[i][j] = result[i-1][j-1];
                    if(result[i][j]> 1_000_000_000)
                        result[i][j]%=1_000_000_000;
                }
                else {
                    result[i][j] = result[i - 1][j - 1] + result[i - 1][j + 1];
                    if(result[i][j]> 1_000_000_000)
                        result[i][j]%=1_000_000_000;
                }
            }
        }
        for(int i = 0 ; i <10 ; i++)
            sum+=result[count][i];
        System.out.print(sum%1_000_000_000);
    }
}
